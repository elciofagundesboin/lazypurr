<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <title>LazyPurr</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-family: monospace; font-size: 1.5rem;
            pointer-events: none;
        }

        #audio-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5); /* Fundo semi-transparente */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: background 0.3s;
        }

        #audio-controls:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <button id="audio-controls">
        <i id="audio-icon" class="fa-solid fa-volume-high"></i>
    </button>
    <div id="loading">Carregando...</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CONFIGURAÇÃO DA CENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001933); // Cor de fundo
        scene.fog = new THREE.FogExp2(0x001933, 0.02); // Névoa suave para fundir o chão com o fundo

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 4, 8); // Posição inicial (Isométrica)

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Melhora o brilho do neon
        renderer.toneMappingExposure = 1.5; // Tentar valores entre 1.0 e 2.0
        renderer.shadowMap.enabled = true; // Habilita sombras
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. CONTROLES (Orbit) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Movimento suave
        controls.dampingFactor = 0.05;
        controls.zoomSpeed = 0.5;
        controls.target.set(0, 2, 0); 
        controls.maxPolarAngle = Math.PI / 2; // Impede que a câmera vá para baixo do chão
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.enablePan = true; // Ativa o "arrastar" lateral

        // --- 3. ILUMINAÇÃO GERAL ---
        // Luz Ambiente (fraca)
        const ambientLight = new THREE.AmbientLight(0xBDD6FF, 0.6); 
        scene.add(ambientLight);

        // CONFIGURAÇÃO DOS PONTOS DE LUZ
        // Função auxiliar para criar luzes
        function createPointLight(color, intensity, x, y, z, name) {
            const light = new THREE.PointLight(color, intensity, 20);
            light.position.set(x, y, z);
            light.castShadow = true;
            light.shadow.bias = -0.001; // Reduz artefatos de sombra
            
            // Adiciona um helper (pequena esfera de arame) para ver onde a luz está
            const helper = new THREE.PointLightHelper(light, 0.3);
            //scene.add(helper);
            scene.add(light);
            return light;
        }

        // LUZ 1: Lâmpada do Teto
        const ceilingLight = createPointLight(0xf7ef83, 3, 0, 3.1, 0, 'teto');

        // LUZ 2: Luminária da Mesa
        const deskLight = createPointLight(0xffb300, 0.2, -0.8, 1.96, -2.15, 'mesa');

        // LUZ 3: Luz auxiliar frontal
        //const frontLight = createPointLight(0xffffff, 10, 5, 2, 5, 'front');

        // --- 4. PÓS-PROCESSAMENTO (BLOOM / GLOW) ---
        const renderScene = new RenderPass(scene, camera);

        // Configuração do Bloom (Brilho)
        // Resolution, Strength (força), Radius (espalhamento), Threshold (limite)
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; // O quão brilhante algo precisa ser para brilhar
        bloomPass.strength = 1.2;  // Intensidade do brilho
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.setPixelRatio(window.devicePixelRatio);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 5. CARREGAR O MODELO GLB ---
        const loader = new GLTFLoader();
        let neonMesh = null; // Variável para guardar o letreiro

        // MATERIAL TOON (Apenas para o Gato) ---
        const format = ( renderer.capabilities.isWebGL2 ) ? THREE.RedFormat : THREE.LuminanceFormat;
        const colors = new Uint8Array( [ 0, 128, 255 ] );
        const gradientMap = new THREE.DataTexture( colors, colors.length, 1, format );
        gradientMap.minFilter = THREE.NearestFilter;
        gradientMap.magFilter = THREE.NearestFilter;
        gradientMap.needsUpdate = true;

        loader.load('./quarto.glb', function (gltf) {
            const model = gltf.scene;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // --- LÓGICA DE MATERIAIS ---
                    
                    // Gato
                    if (child.name === 'cat') {
                        child.material = new THREE.MeshToonMaterial({
                            color: 0xC800FF,
                            gradientMap: gradientMap,
                        });
                    }

                    // Paredes
                    else if (child.name === 'Paredes') {
                        child.material = new THREE.MeshToonMaterial({
                            color: 0xB8AB9A,
                            gradientMap: gradientMap,
                        });
                    }

                    // Piso
                    else if (child.name === 'Piso') {
                        child.material = new THREE.MeshToonMaterial({
                            color: 0xa36f49,
                            gradientMap: gradientMap,
                        });
                    }

                    // Letreiro Neon
                    else if (child.name === 'SOON') {
                        neonMesh = child;
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x14002E,
                            emissive: 0x4A00BA,
                            emissiveIntensity: 10,
                            roughness: 0.4,
                            metalness: 0.1,
                            toneMapped: false // Ajuda o neon a brilhar mais sem perder cor
                        });
                    }
                }
            });
            scene.add(model);
            document.getElementById('loading').style.display = 'none';

        }, undefined, function (error) {
            console.error(error);
        });

        // --- 6. ANIMAÇÃO E LÓGICA DO PISCA-PISCA ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Lógica do Neon Intermitente
            if (neonMesh) {
                // Sorteia um número. Se for muito alto (>0.95), dá uma falha na luz
                // Se for baixo, mantém aceso.
                const flicker = Math.random();
                
                if (flicker > 0.96) {
                    // Apaga momentaneamente (falha)
                    neonMesh.material.emissiveIntensity = 0.2;
                } else if (flicker > 0.92) {
                    // Meia luz
                    neonMesh.material.emissiveIntensity = 1.5;
                } else {
                    // Aceso normal
                    neonMesh.material.emissiveIntensity = 4; // Ajuste este valor para mais/menos brilho
                }
            }

            // Importante: Usar composer.render() ao invés de renderer.render() para ter o Bloom
            composer.render();
        }

        // --- CONFIGURAÇÃO DE ÁUDIO ---
        
        // 1. Criar o "Ouvinte" e adicionar à câmera
        const listener = new THREE.AudioListener();
        camera.add(listener);

        // 2. Criar a fonte de som global (som ambiente)
        const sound = new THREE.Audio(listener);

        // 3. Carregar o arquivo
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('./cat_purring.mp3', function(buffer) {
            sound.setBuffer(buffer);
            sound.setLoop(true); // Loop infinito
            sound.setVolume(0.5); // 50% do volume
        });

        // 4. Lógica de "Autoplay" na primeira interação
        // O navegador só libera o áudio após um clique. Para corrigir rpecisa usar um evento "one-time"
        function startAudioOnInteraction() {
            // Tenta tocar se o som estiver carregado e não estiver tocando
            if (sound.buffer && !sound.isPlaying) {
                sound.play();
                // Remove o evento para não tentar tocar toda vez que clicar
                window.removeEventListener('click', startAudioOnInteraction);
                window.removeEventListener('keydown', startAudioOnInteraction);
            }
        }

        // Adiciona ouvintes para detectar o primeiro clique do usuário
        window.addEventListener('click', startAudioOnInteraction);
        window.addEventListener('keydown', startAudioOnInteraction);


        // --- LÓGICA DO BOTÃO DE MUTAR ---
        const muteBtn = document.getElementById('audio-controls');
        const muteIcon = document.getElementById('audio-icon');
        let isMuted = false;

        muteBtn.addEventListener('click', (event) => {
            // Impede que o clique no botão ative o "startAudioOnInteraction" duplicado
            event.stopPropagation(); 

            if (!sound.buffer) return; // Se o áudio não carregou, não faz nada

            if (isMuted) {
                // DESMUTAR
                sound.play();
                muteIcon.classList.remove('fa-volume-xmark');
                muteIcon.classList.add('fa-volume-high');
                isMuted = false;
                
                // Garante que o listener de início automático morra se o usuário clicou aqui
                window.removeEventListener('click', startAudioOnInteraction);
            } else {
                // MUTAR
                sound.pause();
                muteIcon.classList.remove('fa-volume-high');
                muteIcon.classList.add('fa-volume-xmark');
                isMuted = true;
            }
        });

        // --- FUNÇÃO DE REDIMENSIONAMENTO INTELIGENTE ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            
            camera.aspect = aspect;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            composer.setPixelRatio(window.devicePixelRatio);

            // Se a proporção for menor que 1 (Retrato/Vertical), ajustamos o zoom.
            // A lógica é: zoom = aspect. Isso mantém a largura visível constante.
            if (aspect < 1) { // Vertical
                camera.zoom = aspect / 0.95; 
            } else {
                camera.zoom = 1; // No PC (Paisagem), zoom normal
            }
            
            camera.updateProjectionMatrix(); // Aplica a mudança de zoom

            // Atualiza a espessura das linhas (se estiver usando)
            scene.traverse((object) => {
                if (object.isLineSegments2) {
                    object.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }

        // Adiciona o ouvinte de evento
        window.addEventListener('resize', onWindowResize, false);
        
        onWindowResize();

        animate();
    </script>
</body>
</html>